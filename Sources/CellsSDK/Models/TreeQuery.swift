//
// TreeQuery.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

public final class TreeQuery: Codable, JSONEncodable, Hashable {

    public var content: String?
    public var durationDate: String?
    public var eTag: String?
    public var _extension: String?
    public var fileName: String?
    public var fileNameOrContent: String?
    /** Bleve-like search query to search for a specific metadata value. When querying nodes, this will redirect this query to the Search Engine. When filtering an input, this will load an in-memory bleve engine to evaluate the node.  Bleve query string format is a space separated list of `[+-]key:value`, where node meta keys must be prepended with \"Meta.\" For Example, for tags: `+Meta.usermeta-tags:myvalue` */
    public var freeString: String?
    public var geoQuery: TreeGeoQuery?
    public var maxDate: String?
    public var maxSize: String?
    public var minDate: String?
    public var minSize: String?
    public var not: Bool?
    public var pathDepth: Int?
    public var pathPrefix: [String]?
    public var paths: [String]?
    public var type: TreeNodeType?
    public var uUIDs: [String]?

    public init(content: String? = nil, durationDate: String? = nil, eTag: String? = nil, _extension: String? = nil, fileName: String? = nil, fileNameOrContent: String? = nil, freeString: String? = nil, geoQuery: TreeGeoQuery? = nil, maxDate: String? = nil, maxSize: String? = nil, minDate: String? = nil, minSize: String? = nil, not: Bool? = nil, pathDepth: Int? = nil, pathPrefix: [String]? = nil, paths: [String]? = nil, type: TreeNodeType? = nil, uUIDs: [String]? = nil) {
        self.content = content
        self.durationDate = durationDate
        self.eTag = eTag
        self._extension = _extension
        self.fileName = fileName
        self.fileNameOrContent = fileNameOrContent
        self.freeString = freeString
        self.geoQuery = geoQuery
        self.maxDate = maxDate
        self.maxSize = maxSize
        self.minDate = minDate
        self.minSize = minSize
        self.not = not
        self.pathDepth = pathDepth
        self.pathPrefix = pathPrefix
        self.paths = paths
        self.type = type
        self.uUIDs = uUIDs
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case content = "Content"
        case durationDate = "DurationDate"
        case eTag = "ETag"
        case _extension = "Extension"
        case fileName = "FileName"
        case fileNameOrContent = "FileNameOrContent"
        case freeString = "FreeString"
        case geoQuery = "GeoQuery"
        case maxDate = "MaxDate"
        case maxSize = "MaxSize"
        case minDate = "MinDate"
        case minSize = "MinSize"
        case not = "Not"
        case pathDepth = "PathDepth"
        case pathPrefix = "PathPrefix"
        case paths = "Paths"
        case type = "Type"
        case uUIDs = "UUIDs"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(content, forKey: .content)
        try container.encodeIfPresent(durationDate, forKey: .durationDate)
        try container.encodeIfPresent(eTag, forKey: .eTag)
        try container.encodeIfPresent(_extension, forKey: ._extension)
        try container.encodeIfPresent(fileName, forKey: .fileName)
        try container.encodeIfPresent(fileNameOrContent, forKey: .fileNameOrContent)
        try container.encodeIfPresent(freeString, forKey: .freeString)
        try container.encodeIfPresent(geoQuery, forKey: .geoQuery)
        try container.encodeIfPresent(maxDate, forKey: .maxDate)
        try container.encodeIfPresent(maxSize, forKey: .maxSize)
        try container.encodeIfPresent(minDate, forKey: .minDate)
        try container.encodeIfPresent(minSize, forKey: .minSize)
        try container.encodeIfPresent(not, forKey: .not)
        try container.encodeIfPresent(pathDepth, forKey: .pathDepth)
        try container.encodeIfPresent(pathPrefix, forKey: .pathPrefix)
        try container.encodeIfPresent(paths, forKey: .paths)
        try container.encodeIfPresent(type, forKey: .type)
        try container.encodeIfPresent(uUIDs, forKey: .uUIDs)
    }

    public static func == (lhs: TreeQuery, rhs: TreeQuery) -> Bool {
        lhs.content == rhs.content &&
        lhs.durationDate == rhs.durationDate &&
        lhs.eTag == rhs.eTag &&
        lhs._extension == rhs._extension &&
        lhs.fileName == rhs.fileName &&
        lhs.fileNameOrContent == rhs.fileNameOrContent &&
        lhs.freeString == rhs.freeString &&
        lhs.geoQuery == rhs.geoQuery &&
        lhs.maxDate == rhs.maxDate &&
        lhs.maxSize == rhs.maxSize &&
        lhs.minDate == rhs.minDate &&
        lhs.minSize == rhs.minSize &&
        lhs.not == rhs.not &&
        lhs.pathDepth == rhs.pathDepth &&
        lhs.pathPrefix == rhs.pathPrefix &&
        lhs.paths == rhs.paths &&
        lhs.type == rhs.type &&
        lhs.uUIDs == rhs.uUIDs
        
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(content?.hashValue)
        hasher.combine(durationDate?.hashValue)
        hasher.combine(eTag?.hashValue)
        hasher.combine(_extension?.hashValue)
        hasher.combine(fileName?.hashValue)
        hasher.combine(fileNameOrContent?.hashValue)
        hasher.combine(freeString?.hashValue)
        hasher.combine(geoQuery?.hashValue)
        hasher.combine(maxDate?.hashValue)
        hasher.combine(maxSize?.hashValue)
        hasher.combine(minDate?.hashValue)
        hasher.combine(minSize?.hashValue)
        hasher.combine(not?.hashValue)
        hasher.combine(pathDepth?.hashValue)
        hasher.combine(pathPrefix?.hashValue)
        hasher.combine(paths?.hashValue)
        hasher.combine(type?.hashValue)
        hasher.combine(uUIDs?.hashValue)
        
    }
}

