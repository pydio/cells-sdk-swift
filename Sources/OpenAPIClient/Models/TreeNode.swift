//
// TreeNode.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

public final class TreeNode: Codable, JSONEncodable, Hashable {

    public var appearsIn: [TreeWorkspaceRelativePath]?
    public var commits: [TreeChangeLog]?
    public var etag: String?
    public var mTime: String?
    public var metaStore: [String: String]?
    /** Permission mode, like 0777. Stored as string using custom ModeString field. */
    public var mode: Int?
    public var modeString: String?
    public var path: String?
    public var size: String?
    public var type: TreeNodeType?
    public var uuid: String?

    public init(appearsIn: [TreeWorkspaceRelativePath]? = nil, commits: [TreeChangeLog]? = nil, etag: String? = nil, mTime: String? = nil, metaStore: [String: String]? = nil, mode: Int? = nil, modeString: String? = nil, path: String? = nil, size: String? = nil, type: TreeNodeType? = nil, uuid: String? = nil) {
        self.appearsIn = appearsIn
        self.commits = commits
        self.etag = etag
        self.mTime = mTime
        self.metaStore = metaStore
        self.mode = mode
        self.modeString = modeString
        self.path = path
        self.size = size
        self.type = type
        self.uuid = uuid
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case appearsIn = "AppearsIn"
        case commits = "Commits"
        case etag = "Etag"
        case mTime = "MTime"
        case metaStore = "MetaStore"
        case mode = "Mode"
        case modeString = "ModeString"
        case path = "Path"
        case size = "Size"
        case type = "Type"
        case uuid = "Uuid"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(appearsIn, forKey: .appearsIn)
        try container.encodeIfPresent(commits, forKey: .commits)
        try container.encodeIfPresent(etag, forKey: .etag)
        try container.encodeIfPresent(mTime, forKey: .mTime)
        try container.encodeIfPresent(metaStore, forKey: .metaStore)
        try container.encodeIfPresent(mode, forKey: .mode)
        try container.encodeIfPresent(modeString, forKey: .modeString)
        try container.encodeIfPresent(path, forKey: .path)
        try container.encodeIfPresent(size, forKey: .size)
        try container.encodeIfPresent(type, forKey: .type)
        try container.encodeIfPresent(uuid, forKey: .uuid)
    }

    public static func == (lhs: TreeNode, rhs: TreeNode) -> Bool {
        lhs.appearsIn == rhs.appearsIn &&
        lhs.commits == rhs.commits &&
        lhs.etag == rhs.etag &&
        lhs.mTime == rhs.mTime &&
        lhs.metaStore == rhs.metaStore &&
        lhs.mode == rhs.mode &&
        lhs.modeString == rhs.modeString &&
        lhs.path == rhs.path &&
        lhs.size == rhs.size &&
        lhs.type == rhs.type &&
        lhs.uuid == rhs.uuid
        
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(appearsIn?.hashValue)
        hasher.combine(commits?.hashValue)
        hasher.combine(etag?.hashValue)
        hasher.combine(mTime?.hashValue)
        hasher.combine(metaStore?.hashValue)
        hasher.combine(mode?.hashValue)
        hasher.combine(modeString?.hashValue)
        hasher.combine(path?.hashValue)
        hasher.combine(size?.hashValue)
        hasher.combine(type?.hashValue)
        hasher.combine(uuid?.hashValue)
        
    }
}

