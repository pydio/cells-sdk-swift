//
// RestBackgroundAction.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

public final class RestBackgroundAction: Codable, JSONEncodable, Hashable {

    public var canPause: Bool?
    public var canStop: Bool?
    public var endTime: Int?
    public var hasProgress: Bool?
    public var jobUuid: String
    public var label: String?
    public var name: String
    public var progress: Float?
    public var startTime: Int?
    public var status: JobsTaskStatus?
    public var statusMessage: String?

    public init(canPause: Bool? = nil, canStop: Bool? = nil, endTime: Int? = nil, hasProgress: Bool? = nil, jobUuid: String, label: String? = nil, name: String, progress: Float? = nil, startTime: Int? = nil, status: JobsTaskStatus? = nil, statusMessage: String? = nil) {
        self.canPause = canPause
        self.canStop = canStop
        self.endTime = endTime
        self.hasProgress = hasProgress
        self.jobUuid = jobUuid
        self.label = label
        self.name = name
        self.progress = progress
        self.startTime = startTime
        self.status = status
        self.statusMessage = statusMessage
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case canPause = "CanPause"
        case canStop = "CanStop"
        case endTime = "EndTime"
        case hasProgress = "HasProgress"
        case jobUuid = "JobUuid"
        case label = "Label"
        case name = "Name"
        case progress = "Progress"
        case startTime = "StartTime"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(canPause, forKey: .canPause)
        try container.encodeIfPresent(canStop, forKey: .canStop)
        try container.encodeIfPresent(endTime, forKey: .endTime)
        try container.encodeIfPresent(hasProgress, forKey: .hasProgress)
        try container.encode(jobUuid, forKey: .jobUuid)
        try container.encodeIfPresent(label, forKey: .label)
        try container.encode(name, forKey: .name)
        try container.encodeIfPresent(progress, forKey: .progress)
        try container.encodeIfPresent(startTime, forKey: .startTime)
        try container.encodeIfPresent(status, forKey: .status)
        try container.encodeIfPresent(statusMessage, forKey: .statusMessage)
    }

    public static func == (lhs: RestBackgroundAction, rhs: RestBackgroundAction) -> Bool {
        lhs.canPause == rhs.canPause &&
        lhs.canStop == rhs.canStop &&
        lhs.endTime == rhs.endTime &&
        lhs.hasProgress == rhs.hasProgress &&
        lhs.jobUuid == rhs.jobUuid &&
        lhs.label == rhs.label &&
        lhs.name == rhs.name &&
        lhs.progress == rhs.progress &&
        lhs.startTime == rhs.startTime &&
        lhs.status == rhs.status &&
        lhs.statusMessage == rhs.statusMessage
        
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(canPause?.hashValue)
        hasher.combine(canStop?.hashValue)
        hasher.combine(endTime?.hashValue)
        hasher.combine(hasProgress?.hashValue)
        hasher.combine(jobUuid.hashValue)
        hasher.combine(label?.hashValue)
        hasher.combine(name.hashValue)
        hasher.combine(progress?.hashValue)
        hasher.combine(startTime?.hashValue)
        hasher.combine(status?.hashValue)
        hasher.combine(statusMessage?.hashValue)
        
    }
}

