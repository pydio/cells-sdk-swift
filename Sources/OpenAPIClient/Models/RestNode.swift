//
// RestNode.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

public final class RestNode: Codable, JSONEncodable, Hashable {

    public var activities: [ActivityObject]?
    public var contentLock: RestLockInfo?
    public var contentType: String?
    public var contentsHash: String?
    public var contextWorkspace: RestContextWorkspace?
    public var dataSourceFeatures: RestDataSourceFeatures?
    public var folderMeta: [RestCountMeta]?
    public var hashingMethod: String?
    public var imageMeta: RestImageMeta?
    public var isBookmarked: Bool?
    public var isRecycleBin: Bool?
    public var isRecycled: Bool?
    public var metadata: [RestJsonMeta]?
    public var mode: RestMode?
    public var modified: String?
    public var path: String?
    public var previews: [RestFilePreview]?
    public var shares: [RestShareLink]?
    public var size: String?
    public var storageETag: String?
    public var subscriptions: [ActivitySubscription]?
    public var type: TreeNodeType?
    public var userMetadata: [RestUserMeta]?
    public var uuid: String?

    public init(activities: [ActivityObject]? = nil, contentLock: RestLockInfo? = nil, contentType: String? = nil, contentsHash: String? = nil, contextWorkspace: RestContextWorkspace? = nil, dataSourceFeatures: RestDataSourceFeatures? = nil, folderMeta: [RestCountMeta]? = nil, hashingMethod: String? = nil, imageMeta: RestImageMeta? = nil, isBookmarked: Bool? = nil, isRecycleBin: Bool? = nil, isRecycled: Bool? = nil, metadata: [RestJsonMeta]? = nil, mode: RestMode? = nil, modified: String? = nil, path: String? = nil, previews: [RestFilePreview]? = nil, shares: [RestShareLink]? = nil, size: String? = nil, storageETag: String? = nil, subscriptions: [ActivitySubscription]? = nil, type: TreeNodeType? = nil, userMetadata: [RestUserMeta]? = nil, uuid: String? = nil) {
        self.activities = activities
        self.contentLock = contentLock
        self.contentType = contentType
        self.contentsHash = contentsHash
        self.contextWorkspace = contextWorkspace
        self.dataSourceFeatures = dataSourceFeatures
        self.folderMeta = folderMeta
        self.hashingMethod = hashingMethod
        self.imageMeta = imageMeta
        self.isBookmarked = isBookmarked
        self.isRecycleBin = isRecycleBin
        self.isRecycled = isRecycled
        self.metadata = metadata
        self.mode = mode
        self.modified = modified
        self.path = path
        self.previews = previews
        self.shares = shares
        self.size = size
        self.storageETag = storageETag
        self.subscriptions = subscriptions
        self.type = type
        self.userMetadata = userMetadata
        self.uuid = uuid
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case activities = "Activities"
        case contentLock = "ContentLock"
        case contentType = "ContentType"
        case contentsHash = "ContentsHash"
        case contextWorkspace = "ContextWorkspace"
        case dataSourceFeatures = "DataSourceFeatures"
        case folderMeta = "FolderMeta"
        case hashingMethod = "HashingMethod"
        case imageMeta = "ImageMeta"
        case isBookmarked = "IsBookmarked"
        case isRecycleBin = "IsRecycleBin"
        case isRecycled = "IsRecycled"
        case metadata = "Metadata"
        case mode = "Mode"
        case modified = "Modified"
        case path = "Path"
        case previews = "Previews"
        case shares = "Shares"
        case size = "Size"
        case storageETag = "StorageETag"
        case subscriptions = "Subscriptions"
        case type = "Type"
        case userMetadata = "UserMetadata"
        case uuid = "Uuid"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(activities, forKey: .activities)
        try container.encodeIfPresent(contentLock, forKey: .contentLock)
        try container.encodeIfPresent(contentType, forKey: .contentType)
        try container.encodeIfPresent(contentsHash, forKey: .contentsHash)
        try container.encodeIfPresent(contextWorkspace, forKey: .contextWorkspace)
        try container.encodeIfPresent(dataSourceFeatures, forKey: .dataSourceFeatures)
        try container.encodeIfPresent(folderMeta, forKey: .folderMeta)
        try container.encodeIfPresent(hashingMethod, forKey: .hashingMethod)
        try container.encodeIfPresent(imageMeta, forKey: .imageMeta)
        try container.encodeIfPresent(isBookmarked, forKey: .isBookmarked)
        try container.encodeIfPresent(isRecycleBin, forKey: .isRecycleBin)
        try container.encodeIfPresent(isRecycled, forKey: .isRecycled)
        try container.encodeIfPresent(metadata, forKey: .metadata)
        try container.encodeIfPresent(mode, forKey: .mode)
        try container.encodeIfPresent(modified, forKey: .modified)
        try container.encodeIfPresent(path, forKey: .path)
        try container.encodeIfPresent(previews, forKey: .previews)
        try container.encodeIfPresent(shares, forKey: .shares)
        try container.encodeIfPresent(size, forKey: .size)
        try container.encodeIfPresent(storageETag, forKey: .storageETag)
        try container.encodeIfPresent(subscriptions, forKey: .subscriptions)
        try container.encodeIfPresent(type, forKey: .type)
        try container.encodeIfPresent(userMetadata, forKey: .userMetadata)
        try container.encodeIfPresent(uuid, forKey: .uuid)
    }

    public static func == (lhs: RestNode, rhs: RestNode) -> Bool {
        lhs.activities == rhs.activities &&
        lhs.contentLock == rhs.contentLock &&
        lhs.contentType == rhs.contentType &&
        lhs.contentsHash == rhs.contentsHash &&
        lhs.contextWorkspace == rhs.contextWorkspace &&
        lhs.dataSourceFeatures == rhs.dataSourceFeatures &&
        lhs.folderMeta == rhs.folderMeta &&
        lhs.hashingMethod == rhs.hashingMethod &&
        lhs.imageMeta == rhs.imageMeta &&
        lhs.isBookmarked == rhs.isBookmarked &&
        lhs.isRecycleBin == rhs.isRecycleBin &&
        lhs.isRecycled == rhs.isRecycled &&
        lhs.metadata == rhs.metadata &&
        lhs.mode == rhs.mode &&
        lhs.modified == rhs.modified &&
        lhs.path == rhs.path &&
        lhs.previews == rhs.previews &&
        lhs.shares == rhs.shares &&
        lhs.size == rhs.size &&
        lhs.storageETag == rhs.storageETag &&
        lhs.subscriptions == rhs.subscriptions &&
        lhs.type == rhs.type &&
        lhs.userMetadata == rhs.userMetadata &&
        lhs.uuid == rhs.uuid
        
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(activities?.hashValue)
        hasher.combine(contentLock?.hashValue)
        hasher.combine(contentType?.hashValue)
        hasher.combine(contentsHash?.hashValue)
        hasher.combine(contextWorkspace?.hashValue)
        hasher.combine(dataSourceFeatures?.hashValue)
        hasher.combine(folderMeta?.hashValue)
        hasher.combine(hashingMethod?.hashValue)
        hasher.combine(imageMeta?.hashValue)
        hasher.combine(isBookmarked?.hashValue)
        hasher.combine(isRecycleBin?.hashValue)
        hasher.combine(isRecycled?.hashValue)
        hasher.combine(metadata?.hashValue)
        hasher.combine(mode?.hashValue)
        hasher.combine(modified?.hashValue)
        hasher.combine(path?.hashValue)
        hasher.combine(previews?.hashValue)
        hasher.combine(shares?.hashValue)
        hasher.combine(size?.hashValue)
        hasher.combine(storageETag?.hashValue)
        hasher.combine(subscriptions?.hashValue)
        hasher.combine(type?.hashValue)
        hasher.combine(userMetadata?.hashValue)
        hasher.combine(uuid?.hashValue)
        
    }
}

