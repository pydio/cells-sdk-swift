//
// TreeSearchFacet.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

public final class TreeSearchFacet: Codable, JSONEncodable, Hashable {

    public var count: Int?
    public var end: Int?
    public var fieldName: String?
    public var label: String?
    public var max: String?
    public var min: String?
    public var start: Int?
    public var term: String?

    public init(count: Int? = nil, end: Int? = nil, fieldName: String? = nil, label: String? = nil, max: String? = nil, min: String? = nil, start: Int? = nil, term: String? = nil) {
        self.count = count
        self.end = end
        self.fieldName = fieldName
        self.label = label
        self.max = max
        self.min = min
        self.start = start
        self.term = term
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case count = "Count"
        case end = "End"
        case fieldName = "FieldName"
        case label = "Label"
        case max = "Max"
        case min = "Min"
        case start = "Start"
        case term = "Term"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(count, forKey: .count)
        try container.encodeIfPresent(end, forKey: .end)
        try container.encodeIfPresent(fieldName, forKey: .fieldName)
        try container.encodeIfPresent(label, forKey: .label)
        try container.encodeIfPresent(max, forKey: .max)
        try container.encodeIfPresent(min, forKey: .min)
        try container.encodeIfPresent(start, forKey: .start)
        try container.encodeIfPresent(term, forKey: .term)
    }

    public static func == (lhs: TreeSearchFacet, rhs: TreeSearchFacet) -> Bool {
        lhs.count == rhs.count &&
        lhs.end == rhs.end &&
        lhs.fieldName == rhs.fieldName &&
        lhs.label == rhs.label &&
        lhs.max == rhs.max &&
        lhs.min == rhs.min &&
        lhs.start == rhs.start &&
        lhs.term == rhs.term
        
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(count?.hashValue)
        hasher.combine(end?.hashValue)
        hasher.combine(fieldName?.hashValue)
        hasher.combine(label?.hashValue)
        hasher.combine(max?.hashValue)
        hasher.combine(min?.hashValue)
        hasher.combine(start?.hashValue)
        hasher.combine(term?.hashValue)
        
    }
}

